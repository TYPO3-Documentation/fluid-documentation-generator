<?xml version="1.0" encoding="UTF-8"?>
<xsd:schema xmlns:xsd="http://www.w3.org/2001/XMLSchema" targetNamespace="http://typo3.org/ns/TYPO3Fluid/Fluid/ViewHelpers">
			<xsd:element name="alias"><xsd:annotation><xsd:documentation><![CDATA[Declares new variables which are aliases of other variables.
Takes a "map"-Parameter which is an associative array which defines the shorthand mapping.

The variables are only declared inside the ``<f:alias>...</f:alias>`` tag. After the
closing tag, all declared variables are removed again.

Using this ViewHelper can be a sign of weak architecture. If you end up
using it extensively you might want to fine-tune your "view model" (the
data you assign to the view).

Examples
========

Single alias
------------

::

    <f:alias map="{x: 'foo'}">{x}</f:alias>

Output::

    foo

Multiple mappings
-----------------

::

    <f:alias map="{x: foo.bar.baz, y: foo.bar.baz.name}">
        {x.name} or {y}
    </f:alias>

Output::

    [name] or [name]

Depending on ``{foo.bar.baz}``.


/]]></xsd:documentation></xsd:annotation><xsd:complexType mixed="true"><xsd:sequence><xsd:any minOccurs="0" maxOccurs="1"/></xsd:sequence><xsd:attribute type="xsd:anySimpleType" name="map" default="NULL" use="required"><xsd:annotation><xsd:documentation><![CDATA[Array that specifies which variables should be mapped to which alias]]></xsd:documentation></xsd:annotation></xsd:attribute></xsd:complexType></xsd:element><xsd:element name="cache.disable"><xsd:annotation><xsd:documentation><![CDATA[ViewHelper to disable template compiling

Inserting this ViewHelper at any point in the template,
including inside conditions which do not get rendered,
will forcibly disable the caching/compiling of the full
template file to a PHP class.

Use this if for whatever reason your platform is unable
to create or load PHP classes (for example on read-only
file systems or when using an incompatible default cache
backend).

Passes through anything you place inside the ViewHelper,
so can safely be used as container tag, as self-closing
or with inline syntax - all with the same result.

Examples
========

Self-closing
------------

::

    <f:cache.disable />

Inline mode
-----------

::

    {f:cache.disable()}


Container tag
-------------

::

    <f:cache.disable>
       Some output or Fluid code
    </f:cache.disable>

Additional output is also not compilable because of the ViewHelper

/]]></xsd:documentation></xsd:annotation><xsd:complexType mixed="true"><xsd:sequence><xsd:any minOccurs="0" maxOccurs="1"/></xsd:sequence></xsd:complexType></xsd:element><xsd:element name="cache.static"><xsd:annotation><xsd:documentation><![CDATA[ViewHelper to force compiling to a static string

Used around chunks of template code where you want the
output of said template code to be compiled to a static
string (rather than a collection of compiled nodes, as
is the usual behavior).

The effect is that none of the child ViewHelpers or nodes
used inside this tag will be evaluated when rendering the
template once it is compiled. It will essentially replace
all logic inside the tag with a plain string output.

Works by turning the ``compile`` method into a method that
renders the child nodes and returns the resulting content
directly as a string variable.

You can use this with great effect to further optimise the
performance of your templates: in use cases where chunks of
template code depend on static variables (like thoese in
``{settings}`` for example) and those variables never change,
and the template uses no other dynamic variables, forcing
the template to compile that chunk to a static string can
save a lot of operations when rendering the compiled template.

NB: NOT TO BE USED FOR CACHING ANYTHING OTHER THAN STRING-
COMPATIBLE OUTPUT!

USE WITH CARE! WILL PRESERVE EVERYTHING RENDERED, INCLUDING
POTENTIALLY SENSITIVE DATA CONTAINED IN OUTPUT!

Examples
========

Usage and effect
----------------

::

    <f:if condition="{var}">Is always evaluated also when compiled</f:if>
    <f:cache.static>
        <f:if condition="{othervar}">
            Will only be evaluated once and this output will be
            cached as a static string with no logic attached.
            The compiled template will not contain neither the
            condition ViewHelperNodes or the variable accessor
            that are used inside this node.
        </f:if>
    </f:cache.static>

This is also evaluated when compiled (static node is closed)::

    <f:if condition="{var}">Also evaluated; is outside static node</f:if>

/]]></xsd:documentation></xsd:annotation><xsd:complexType mixed="true"><xsd:sequence><xsd:any minOccurs="0" maxOccurs="1"/></xsd:sequence></xsd:complexType></xsd:element><xsd:element name="cache.warmup"><xsd:annotation><xsd:documentation><![CDATA[ViewHelper to insert variables which only apply during
cache warmup and only apply if no other variables are
specified for the warmup process.

If a chunk of template code is impossible to compile
without additional variables, for example when rendering
sections or partials using dynamic names, you can use this
ViewHelper around that chunk and specify a set of variables
which will be assigned only while compiling the template
and only when this is done as part of cache warmup. The
template chunk can then be compiled using those default
variables.

This does not imply that only those variable values will
be used by the compiled template. It only means that
DEFAULT values of vital variables will be present during
compiling.

If you find yourself completely unable to properly warm up
a specific template file even with use of this ViewHelper,
then you can consider using
``f:cache.disable`` ViewHelper
to prevent the template compiler from even attempting to
compile it.

USE WITH CARE! SOME EDGE CASES OF FOR EXAMPLE VIEWHELPERS
WHICH REQUIRE SPECIAL VARIABLE TYPES MAY NOT BE SUPPORTED
HERE DUE TO THE RUDIMENTARY NATURE OF VARIABLES YOU DEFINE.

Examples
========

Usage and effect
----------------

::

    <f:cache.warmup variables="{foo: bar}">
       Template code depending on {foo} variable which is not
       assigned when warming up Fluid's caches. {foo} is only
       assigned if the variable does not already exist and the
       assignment only happens if Fluid is in warmup mode.
    </f:cache.warmup>

/]]></xsd:documentation></xsd:annotation><xsd:complexType mixed="true"><xsd:sequence><xsd:any minOccurs="0" maxOccurs="1"/></xsd:sequence><xsd:attribute type="xsd:anySimpleType" name="variables" default="array (&#10;)"><xsd:annotation><xsd:documentation><![CDATA[Array of variables to assign ONLY when compiling. See main class documentation.]]></xsd:documentation></xsd:annotation></xsd:attribute></xsd:complexType></xsd:element><xsd:element name="case"><xsd:annotation><xsd:documentation><![CDATA[Case ViewHelper that is only usable within the ``f:switch`` ViewHelper.


/]]></xsd:documentation></xsd:annotation><xsd:complexType mixed="true"><xsd:sequence><xsd:any minOccurs="0" maxOccurs="1"/></xsd:sequence><xsd:attribute type="xsd:anySimpleType" name="value" default="NULL" use="required"><xsd:annotation><xsd:documentation><![CDATA[Value to match in this case]]></xsd:documentation></xsd:annotation></xsd:attribute></xsd:complexType></xsd:element><xsd:element name="comment"><xsd:annotation><xsd:documentation><![CDATA[This ViewHelper prevents rendering of any content inside the tag.

Contents of the comment will still be **parsed** thus throwing an
Exception if it contains syntax errors. You can put child nodes in
CDATA tags to avoid this.

Using this ViewHelper won't have a notable effect on performance,
especially once the template is parsed.  However, it can lead to reduced
readability. You can use layouts and partials to split a large template
into smaller parts. Using self-descriptive names for the partials can
make comments redundant.

Examples
========

Commenting out fluid code
-------------------------

::

    Before
    <f:comment>
        This is completely hidden.
        <f:debug>This does not get rendered</f:debug>
    </f:comment>
    After

Output::

    Before
    After

Prevent parsing
---------------

::

    <f:comment><![CDATA[
       <f:some.invalid.syntax />
    ]]]]><![CDATA[></f:comment>

Output:

Will be nothing.

/]]></xsd:documentation></xsd:annotation><xsd:complexType mixed="true"><xsd:sequence><xsd:any minOccurs="0" maxOccurs="1"/></xsd:sequence></xsd:complexType></xsd:element><xsd:element name="count"><xsd:annotation><xsd:documentation><![CDATA[This ViewHelper counts elements of the specified array or countable object.

Examples
========

Count array elements
--------------------

::

    <f:count subject="{0:1, 1:2, 2:3, 3:4}" />

Output::

    4

inline notation
---------------

::

    {objects -> f:count()}

Output::

    10 (depending on the number of items in ``{objects}``)

/]]></xsd:documentation></xsd:annotation><xsd:complexType mixed="true"><xsd:sequence><xsd:any minOccurs="0" maxOccurs="1"/></xsd:sequence><xsd:attribute type="xsd:anySimpleType" name="subject" default="NULL"><xsd:annotation><xsd:documentation><![CDATA[Countable subject, array or \Countable]]></xsd:documentation></xsd:annotation></xsd:attribute></xsd:complexType></xsd:element><xsd:element name="cycle"><xsd:annotation><xsd:documentation><![CDATA[This ViewHelper cycles through the specified values.
This can be often used to specify CSS classes for example.

To achieve the "zebra class" effect in a loop you can also use the
"iteration" argument of the **for** ViewHelper.

Examples
========

These examples could also be achieved using the "iteration" argument
of the ForViewHelper.

Simple
------

::

    <f:for each="{0:1, 1:2, 2:3, 3:4}" as="foo">
        <f:cycle values="{0: 'foo', 1: 'bar', 2: 'baz'}" as="cycle">
            {cycle}
        </f:cycle>
    </f:for>

Output::

    foobarbazfoo

Alternating CSS class
---------------------

::

    <ul>
        <f:for each="{0:1, 1:2, 2:3, 3:4}" as="foo">
            <f:cycle values="{0: 'odd', 1: 'even'}" as="zebraClass">
                <li class="{zebraClass}">{foo}</li>
            </f:cycle>
        </f:for>
    </ul>

Output::

    <ul>
        <li class="odd">1</li>
        <li class="even">2</li>
        <li class="odd">3</li>
        <li class="even">4</li>
    </ul>

/]]></xsd:documentation></xsd:annotation><xsd:complexType mixed="true"><xsd:sequence><xsd:any minOccurs="0" maxOccurs="1"/></xsd:sequence><xsd:attribute type="xsd:anySimpleType" name="values" default="NULL"><xsd:annotation><xsd:documentation><![CDATA[The array or object implementing \ArrayAccess (for example \SplObjectStorage) to iterated over]]></xsd:documentation></xsd:annotation></xsd:attribute><xsd:attribute type="xsd:string" name="as" default="NULL" use="required"><xsd:annotation><xsd:documentation><![CDATA[The name of the iteration variable]]></xsd:documentation></xsd:annotation></xsd:attribute></xsd:complexType></xsd:element><xsd:element name="debug"><xsd:annotation><xsd:documentation><![CDATA[This ViewHelper is only meant to be used during development.

Examples
========

Inline notation and custom title
--------------------------------

::

    {object -> f:debug(title: 'Custom title')}

Output::

    all properties of {object} nicely highlighted (with custom title)

Only output the type
--------------------

::

    {object -> f:debug(typeOnly: true)}

Output::

    the type or class name of {object}

/]]></xsd:documentation></xsd:annotation><xsd:complexType mixed="true"><xsd:sequence><xsd:any minOccurs="0" maxOccurs="1"/></xsd:sequence><xsd:attribute type="xsd:boolean" name="typeOnly" default="false"><xsd:annotation><xsd:documentation><![CDATA[If TRUE, debugs only the type of variables]]></xsd:documentation></xsd:annotation></xsd:attribute><xsd:attribute type="xsd:integer" name="levels" default="5"><xsd:annotation><xsd:documentation><![CDATA[Levels to render when rendering nested objects/arrays]]></xsd:documentation></xsd:annotation></xsd:attribute><xsd:attribute type="xsd:boolean" name="html" default="false"><xsd:annotation><xsd:documentation><![CDATA[Render HTML. If FALSE, output is indented plaintext]]></xsd:documentation></xsd:annotation></xsd:attribute></xsd:complexType></xsd:element><xsd:element name="defaultCase"><xsd:annotation><xsd:documentation><![CDATA[A ViewHelper which specifies the "default" case when used within the ``f:switch`` ViewHelper.


/]]></xsd:documentation></xsd:annotation><xsd:complexType mixed="true"><xsd:sequence><xsd:any minOccurs="0" maxOccurs="1"/></xsd:sequence></xsd:complexType></xsd:element><xsd:element name="else"><xsd:annotation><xsd:documentation><![CDATA[Else-Branch of a condition. Only has an effect inside of ``f:if``.
See the ``f:if`` ViewHelper for documentation.

Examples
========

Output content if condition is not met
--------------------------------------

::

    <f:if condition="{someCondition}">
        <f:else>
            condition was not true
        </f:else>
    </f:if>

Output::

    Everything inside the "else" tag is displayed if the condition evaluates to FALSE.
    Otherwise nothing is outputted in this example.

/]]></xsd:documentation></xsd:annotation><xsd:complexType mixed="true"><xsd:sequence><xsd:any minOccurs="0" maxOccurs="1"/></xsd:sequence><xsd:attribute type="xsd:boolean" name="if" default="NULL"><xsd:annotation><xsd:documentation><![CDATA[Condition expression conforming to Fluid boolean rules]]></xsd:documentation></xsd:annotation></xsd:attribute></xsd:complexType></xsd:element><xsd:element name="first"><xsd:annotation><xsd:documentation><![CDATA[The FirstViewHelper returns the first item of an array.

Example
========

::

   <f:first value="{0: 'first', 1: 'second'}" />

.. code-block:: text

   first
/]]></xsd:documentation></xsd:annotation><xsd:complexType mixed="true"><xsd:sequence><xsd:any minOccurs="0" maxOccurs="1"/></xsd:sequence><xsd:attribute type="xsd:anySimpleType" name="value" default="NULL"><xsd:annotation><xsd:documentation><![CDATA[]]></xsd:documentation></xsd:annotation></xsd:attribute></xsd:complexType></xsd:element><xsd:element name="for"><xsd:annotation><xsd:documentation><![CDATA[Loop ViewHelper which can be used to iterate over arrays.
Implements what a basic PHP ``foreach()`` does.

Examples
========

Simple Loop
-----------

::

    <f:for each="{0:1, 1:2, 2:3, 3:4}" as="foo">{foo}</f:for>

Output::

    1234

Output array key
----------------

::

    <ul>
        <f:for each="{fruit1: 'apple', fruit2: 'pear', fruit3: 'banana', fruit4: 'cherry'}"
            as="fruit" key="label"
        >
            <li>{label}: {fruit}</li>
        </f:for>
    </ul>

Output::

    <ul>
        <li>fruit1: apple</li>
        <li>fruit2: pear</li>
        <li>fruit3: banana</li>
        <li>fruit4: cherry</li>
    </ul>

Iteration information
---------------------

::

    <ul>
        <f:for each="{0:1, 1:2, 2:3, 3:4}" as="foo" iteration="fooIterator">
            <li>Index: {fooIterator.index} Cycle: {fooIterator.cycle} Total: {fooIterator.total}{f:if(condition: fooIterator.isEven, then: ' Even')}{f:if(condition: fooIterator.isOdd, then: ' Odd')}{f:if(condition: fooIterator.isFirst, then: ' First')}{f:if(condition: fooIterator.isLast, then: ' Last')}</li>
        </f:for>
    </ul>

Output::

    <ul>
        <li>Index: 0 Cycle: 1 Total: 4 Odd First</li>
        <li>Index: 1 Cycle: 2 Total: 4 Even</li>
        <li>Index: 2 Cycle: 3 Total: 4 Odd</li>
        <li>Index: 3 Cycle: 4 Total: 4 Even Last</li>
    </ul>

/]]></xsd:documentation></xsd:annotation><xsd:complexType mixed="true"><xsd:sequence><xsd:any minOccurs="0" maxOccurs="1"/></xsd:sequence><xsd:attribute type="xsd:anySimpleType" name="each" default="NULL" use="required"><xsd:annotation><xsd:documentation><![CDATA[The array or \SplObjectStorage to iterated over]]></xsd:documentation></xsd:annotation></xsd:attribute><xsd:attribute type="xsd:string" name="as" default="NULL" use="required"><xsd:annotation><xsd:documentation><![CDATA[The name of the iteration variable]]></xsd:documentation></xsd:annotation></xsd:attribute><xsd:attribute type="xsd:string" name="key" default="NULL"><xsd:annotation><xsd:documentation><![CDATA[Variable to assign array key to]]></xsd:documentation></xsd:annotation></xsd:attribute><xsd:attribute type="xsd:boolean" name="reverse" default="false"><xsd:annotation><xsd:documentation><![CDATA[If TRUE, iterates in reverse]]></xsd:documentation></xsd:annotation></xsd:attribute><xsd:attribute type="xsd:string" name="iteration" default="NULL"><xsd:annotation><xsd:documentation><![CDATA[The name of the variable to store iteration information (index, cycle, total, isFirst, isLast, isEven, isOdd)]]></xsd:documentation></xsd:annotation></xsd:attribute></xsd:complexType></xsd:element><xsd:element name="format.case"><xsd:annotation><xsd:documentation><![CDATA[Modifies the case of an input string to upper- or lowercase or capitalization.
The default transformation will be uppercase as in `mb_convert_case`_.

Possible modes are:

``lower``
  Transforms the input string to its lowercase representation

``upper``
  Transforms the input string to its uppercase representation

``capital``
  Transforms the input string to its first letter upper-cased, i.e. capitalization

``uncapital``
  Transforms the input string to its first letter lower-cased, i.e. uncapitalization

``capitalWords``
  Not supported yet: Transforms the input string to each containing word being capitalized

Note that the behavior will be the same as in the appropriate PHP function `mb_convert_case`_;
especially regarding locale and multibyte behavior.

.. _mb_convert_case: https://www.php.net/manual/function.mb-convert-case.php

Examples
========

Default
-------

::

   <f:format.case>Some Text with miXed case</f:format.case>

Output::

   SOME TEXT WITH MIXED CASE

Example with given mode
-----------------------

::

   <f:format.case mode="capital">someString</f:format.case>

Output::

   SomeString
/]]></xsd:documentation></xsd:annotation><xsd:complexType mixed="true"><xsd:sequence><xsd:any minOccurs="0" maxOccurs="1"/></xsd:sequence><xsd:attribute type="xsd:string" name="value" default="NULL"><xsd:annotation><xsd:documentation><![CDATA[The input value. If not given, the evaluated child nodes will be used.]]></xsd:documentation></xsd:annotation></xsd:attribute><xsd:attribute type="xsd:string" name="mode" default="'upper'"><xsd:annotation><xsd:documentation><![CDATA[The case to apply, must be one of this' CASE_* constants. Defaults to uppercase application.]]></xsd:documentation></xsd:annotation></xsd:attribute></xsd:complexType></xsd:element><xsd:element name="format.cdata"><xsd:annotation><xsd:documentation><![CDATA[Outputs an argument/value without any escaping and wraps it with CDATA tags.

PAY SPECIAL ATTENTION TO SECURITY HERE (especially Cross Site Scripting),
as the output is NOT SANITIZED!

Examples
========

Child nodes
-----------

::

    <f:format.cdata>{string}</f:format.cdata>

Output::

    <![CDATA[(Content of {string} without any conversion/escaping)]]]]><![CDATA[>

Value attribute
---------------

::

    <f:format.cdata value="{string}" />

Output::

    <![CDATA[(Content of {string} without any conversion/escaping)]]]]><![CDATA[>

Inline notation
---------------

::

    {string -> f:format.cdata()}

Output::

    <![CDATA[(Content of {string} without any conversion/escaping)]]]]><![CDATA[>

/]]></xsd:documentation></xsd:annotation><xsd:complexType mixed="true"><xsd:sequence><xsd:any minOccurs="0" maxOccurs="1"/></xsd:sequence><xsd:attribute type="xsd:anySimpleType" name="value" default="NULL"><xsd:annotation><xsd:documentation><![CDATA[The value to output]]></xsd:documentation></xsd:annotation></xsd:attribute></xsd:complexType></xsd:element><xsd:element name="format.htmlspecialchars"><xsd:annotation><xsd:documentation><![CDATA[Applies PHP ``htmlspecialchars()`` escaping to a value.

See http://www.php.net/manual/function.htmlspecialchars.php

Examples
========

Default notation
----------------

::

    <f:format.htmlspecialchars>{text}</f:format.htmlspecialchars>

Output::

    Text with & " ' < > * replaced by HTML entities (htmlspecialchars applied).

Inline notation
---------------

::

    {text -> f:format.htmlspecialchars(encoding: 'ISO-8859-1')}

Output::

    Text with & " ' < > * replaced by HTML entities (htmlspecialchars applied).

/]]></xsd:documentation></xsd:annotation><xsd:complexType mixed="true"><xsd:sequence><xsd:any minOccurs="0" maxOccurs="1"/></xsd:sequence><xsd:attribute type="xsd:string" name="value" default="NULL"><xsd:annotation><xsd:documentation><![CDATA[Value to format]]></xsd:documentation></xsd:annotation></xsd:attribute><xsd:attribute type="xsd:boolean" name="keepQuotes" default="false"><xsd:annotation><xsd:documentation><![CDATA[If TRUE quotes will not be replaced (ENT_NOQUOTES)]]></xsd:documentation></xsd:annotation></xsd:attribute><xsd:attribute type="xsd:string" name="encoding" default="'UTF-8'"><xsd:annotation><xsd:documentation><![CDATA[Encoding]]></xsd:documentation></xsd:annotation></xsd:attribute><xsd:attribute type="xsd:boolean" name="doubleEncode" default="true"><xsd:annotation><xsd:documentation><![CDATA[If FALSE html entities will not be encoded]]></xsd:documentation></xsd:annotation></xsd:attribute></xsd:complexType></xsd:element><xsd:element name="format.json"><xsd:annotation><xsd:documentation><![CDATA[Wrapper for PHPs :php:`json_encode` function.
See https://www.php.net/manual/function.json-encode.php.

Examples
========

Encoding a view variable
------------------------

::

   {someArray -> f:format.json()}

``["array","values"]``
Depending on the value of ``{someArray}``.

Associative array
-----------------

::

   {f:format.json(value: {foo: 'bar', bar: 'baz'})}

``{"foo":"bar","bar":"baz"}``

Non associative array with forced object
----------------------------------------

::

   {f:format.json(value: {0: 'bar', 1: 'baz'}, forceObject: true)}

``{"0":"bar","1":"baz"}``
/]]></xsd:documentation></xsd:annotation><xsd:complexType mixed="true"><xsd:sequence><xsd:any minOccurs="0" maxOccurs="1"/></xsd:sequence><xsd:attribute type="xsd:anySimpleType" name="value" default="NULL"><xsd:annotation><xsd:documentation><![CDATA[The incoming data to convert, or null if VH children should be used]]></xsd:documentation></xsd:annotation></xsd:attribute><xsd:attribute type="xsd:boolean" name="forceObject" default="false"><xsd:annotation><xsd:documentation><![CDATA[Outputs an JSON object rather than an array]]></xsd:documentation></xsd:annotation></xsd:attribute></xsd:complexType></xsd:element><xsd:element name="format.nl2br"><xsd:annotation><xsd:documentation><![CDATA[Wrapper for PHPs :php:`nl2br` function.
See https://www.php.net/manual/function.nl2br.php.

Examples
========

Default
-------

::

   <f:format.nl2br>{text_with_linebreaks}</f:format.nl2br>

Text with line breaks replaced by ``<br />``

Inline notation
---------------

::

   {text_with_linebreaks -> f:format.nl2br()}

Text with line breaks replaced by ``<br />``
/]]></xsd:documentation></xsd:annotation><xsd:complexType mixed="true"><xsd:sequence><xsd:any minOccurs="0" maxOccurs="1"/></xsd:sequence><xsd:attribute type="xsd:string" name="value" default="NULL"><xsd:annotation><xsd:documentation><![CDATA[string to format]]></xsd:documentation></xsd:annotation></xsd:attribute></xsd:complexType></xsd:element><xsd:element name="format.number"><xsd:annotation><xsd:documentation><![CDATA[Formats a number with custom precision, decimal point and grouped thousands.
See https://www.php.net/manual/function.number-format.php.

Examples
========

Defaults
--------

::

   <f:format.number>423423.234</f:format.number>

``423,423.20``

With all parameters
-------------------

::

   <f:format.number decimals="1" decimalSeparator="," thousandsSeparator=".">
       423423.234
   </f:format.number>

``423.423,2``
/]]></xsd:documentation></xsd:annotation><xsd:complexType mixed="true"><xsd:sequence><xsd:any minOccurs="0" maxOccurs="1"/></xsd:sequence><xsd:attribute type="xsd:anySimpleType" name="decimals" default="2"><xsd:annotation><xsd:documentation><![CDATA[The number of digits after the decimal point]]></xsd:documentation></xsd:annotation></xsd:attribute><xsd:attribute type="xsd:string" name="decimalSeparator" default="'.'"><xsd:annotation><xsd:documentation><![CDATA[The decimal point character]]></xsd:documentation></xsd:annotation></xsd:attribute><xsd:attribute type="xsd:string" name="thousandsSeparator" default="','"><xsd:annotation><xsd:documentation><![CDATA[The character for grouping the thousand digits]]></xsd:documentation></xsd:annotation></xsd:attribute></xsd:complexType></xsd:element><xsd:element name="format.printf"><xsd:annotation><xsd:documentation><![CDATA[A ViewHelper for formatting values with printf. Either supply an array for
the arguments or a single value.

See http://www.php.net/manual/en/function.sprintf.php

Examples
========

Scientific notation
-------------------

::

    <f:format.printf arguments="{number: 362525200}">%.3e</f:format.printf>

Output::

    3.625e+8

Argument swapping
-----------------

::

    <f:format.printf arguments="{0: 3, 1: 'Kasper'}">%2$s is great, TYPO%1$d too. Yes, TYPO%1$d is great and so is %2$s!</f:format.printf>

Output::

    Kasper is great, TYPO3 too. Yes, TYPO3 is great and so is Kasper!

Single argument
---------------

::

    <f:format.printf arguments="{1: 'TYPO3'}">We love %s</f:format.printf>


Output::

    We love TYPO3

Inline notation
---------------

::

    {someText -> f:format.printf(arguments: {1: 'TYPO3'})}


Output::

    We love TYPO3

/]]></xsd:documentation></xsd:annotation><xsd:complexType mixed="true"><xsd:sequence><xsd:any minOccurs="0" maxOccurs="1"/></xsd:sequence><xsd:attribute type="xsd:string" name="value" default="NULL"><xsd:annotation><xsd:documentation><![CDATA[String to format]]></xsd:documentation></xsd:annotation></xsd:attribute><xsd:attribute type="xsd:anySimpleType" name="arguments" default="array (&#10;)"><xsd:annotation><xsd:documentation><![CDATA[The arguments for vsprintf]]></xsd:documentation></xsd:annotation></xsd:attribute></xsd:complexType></xsd:element><xsd:element name="format.raw"><xsd:annotation><xsd:documentation><![CDATA[Outputs an argument/value without any escaping. Is normally used to output
an ObjectAccessor which should not be escaped, but output as-is.

PAY SPECIAL ATTENTION TO SECURITY HERE (especially Cross Site Scripting),
as the output is NOT SANITIZED!

Examples
========

Child nodes
-----------

::

    <f:format.raw>{string}</f:format.raw>

Output::

    (Content of ``{string}`` without any conversion/escaping)

Value attribute
---------------

::

    <f:format.raw value="{string}" />

Output::

    (Content of ``{string}`` without any conversion/escaping)

Inline notation
---------------

::

    {string -> f:format.raw()}

Output::

    (Content of ``{string}`` without any conversion/escaping)

/]]></xsd:documentation></xsd:annotation><xsd:complexType mixed="true"><xsd:sequence><xsd:any minOccurs="0" maxOccurs="1"/></xsd:sequence><xsd:attribute type="xsd:anySimpleType" name="value" default="NULL"><xsd:annotation><xsd:documentation><![CDATA[The value to output]]></xsd:documentation></xsd:annotation></xsd:attribute></xsd:complexType></xsd:element><xsd:element name="format.stripTags"><xsd:annotation><xsd:documentation><![CDATA[Removes tags from the given string (applying PHPs :php:`strip_tags()` function)
See https://www.php.net/manual/function.strip-tags.php.

Examples
========

Default notation
----------------

::

   <f:format.stripTags>Some Text with <b>Tags</b> and an &Uuml;mlaut.</f:format.stripTags>

Some Text with Tags and an &Uuml;mlaut. :php:`strip_tags()` applied.

.. note::
   Encoded entities are not decoded.

Default notation with allowedTags
---------------------------------

::

   <f:format.stripTags allowedTags="<p><span><div><script>">
       <p>paragraph</p><span>span</span><div>divider</div><iframe>iframe</iframe><script>script</script>
   </f:format.stripTags>

Output::

   <p>paragraph</p><span>span</span><div>divider</div>iframe<script>script</script>

Inline notation
---------------

::

   {text -> f:format.stripTags()}

Text without tags :php:`strip_tags()` applied.

Inline notation with allowedTags
--------------------------------

::

   {text -> f:format.stripTags(allowedTags: "<p><span><div><script>")}

Text with p, span, div and script Tags inside, all other tags are removed.
/]]></xsd:documentation></xsd:annotation><xsd:complexType mixed="true"><xsd:sequence><xsd:any minOccurs="0" maxOccurs="1"/></xsd:sequence><xsd:attribute type="xsd:string" name="value" default="NULL"><xsd:annotation><xsd:documentation><![CDATA[string to format]]></xsd:documentation></xsd:annotation></xsd:attribute><xsd:attribute type="xsd:string" name="allowedTags" default="NULL"><xsd:annotation><xsd:documentation><![CDATA[Optional string of allowed tags as required by PHPs strip_tags() function]]></xsd:documentation></xsd:annotation></xsd:attribute></xsd:complexType></xsd:element><xsd:element name="format.trim"><xsd:annotation><xsd:documentation><![CDATA[This ViewHelper strips whitespace (or other characters) from the beginning and end of a string.

Possible sides are:

``both`` (default)
  Strip whitespace (or other characters) from the beginning and end of a string

``left`` or ``start``
  Strip whitespace (or other characters) from the beginning of a string

``right`` or ``end``
  Strip whitespace (or other characters) from the end of a string


Examples
========

Defaults
--------
::

   #<f:format.trim>   String to be trimmed.   </f:format.trim>#

.. code-block:: text

   #String to be trimmed.#


Trim only one side
------------------

::

   #<f:format.trim side="right">   String to be trimmed.   </f:format.trim>#

.. code-block:: text

   #   String to be trimmed.#


Trim special characters
-----------------------

::

   #<f:format.trim characters=" St.">   String to be trimmed.   </f:format.trim>#

.. code-block:: text

   #ring to be trimmed#
/]]></xsd:documentation></xsd:annotation><xsd:complexType mixed="true"><xsd:sequence><xsd:any minOccurs="0" maxOccurs="1"/></xsd:sequence><xsd:attribute type="xsd:string" name="value" default="NULL"><xsd:annotation><xsd:documentation><![CDATA[The string value to be trimmed. If not given, the evaluated child nodes will be used.]]></xsd:documentation></xsd:annotation></xsd:attribute><xsd:attribute type="xsd:string" name="characters" default="NULL"><xsd:annotation><xsd:documentation><![CDATA[Optionally, the stripped characters can also be specified using the characters parameter. Simply list all characters that you want to be stripped. With .. you can specify a range of characters.]]></xsd:documentation></xsd:annotation></xsd:attribute><xsd:attribute type="xsd:string" name="side" default="'both'"><xsd:annotation><xsd:documentation><![CDATA[The side to apply, must be one of this' CASE_* constants. Defaults to both application.]]></xsd:documentation></xsd:annotation></xsd:attribute></xsd:complexType></xsd:element><xsd:element name="format.urlencode"><xsd:annotation><xsd:documentation><![CDATA[Encodes the given string according to http://www.faqs.org/rfcs/rfc3986.html
Applying PHPs :php:`rawurlencode()` function.
See https://www.php.net/manual/function.rawurlencode.php.

.. note::
   The output is not escaped. You may have to ensure proper escaping on your own.

Examples
========

Default notation
----------------

::

   <f:format.urlencode>foo @+%/</f:format.urlencode>

``foo%20%40%2B%25%2F`` :php:`rawurlencode()` applied.

Inline notation
---------------

::

   {text -> f:format.urlencode()}

Url encoded text :php:`rawurlencode()` applied.
/]]></xsd:documentation></xsd:annotation><xsd:complexType mixed="true"><xsd:sequence><xsd:any minOccurs="0" maxOccurs="1"/></xsd:sequence><xsd:attribute type="xsd:string" name="value" default="NULL"><xsd:annotation><xsd:documentation><![CDATA[string to format]]></xsd:documentation></xsd:annotation></xsd:attribute></xsd:complexType></xsd:element><xsd:element name="groupedFor"><xsd:annotation><xsd:documentation><![CDATA[Grouped loop ViewHelper.
Loops through the specified values.

The groupBy argument also supports property paths.

Using this ViewHelper can be a sign of weak architecture. If you end up
using it extensively you might want to fine-tune your "view model" (the
data you assign to the view).

Examples
========

Simple
------

::

    <f:groupedFor each="{0: {name: 'apple', color: 'green'}, 1: {name: 'cherry', color: 'red'}, 2: {name: 'banana', color: 'yellow'}, 3: {name: 'strawberry', color: 'red'}}"
        as="fruitsOfThisColor" groupBy="color"
    >
        <f:for each="{fruitsOfThisColor}" as="fruit">
            {fruit.name}
        </f:for>
    </f:groupedFor>

Output::

    apple cherry strawberry banana

Two dimensional list
--------------------

::

    <ul>
        <f:groupedFor each="{0: {name: 'apple', color: 'green'}, 1: {name: 'cherry', color: 'red'}, 2: {name: 'banana', color: 'yellow'}, 3: {name: 'strawberry', color: 'red'}}" as="fruitsOfThisColor" groupBy="color" groupKey="color">
            <li>
                {color} fruits:
                <ul>
                    <f:for each="{fruitsOfThisColor}" as="fruit" key="label">
                        <li>{label}: {fruit.name}</li>
                    </f:for>
                </ul>
            </li>
        </f:groupedFor>
    </ul>

Output::

    <ul>
        <li>green fruits
            <ul>
                <li>0: apple</li>
            </ul>
        </li>
        <li>red fruits
            <ul>
                <li>1: cherry</li>
            </ul>
            <ul>
                <li>3: strawberry</li>
            </ul>
        </li>
        <li>yellow fruits
            <ul>
                <li>2: banana</li>
            </ul>
        </li>
    </ul>

/]]></xsd:documentation></xsd:annotation><xsd:complexType mixed="true"><xsd:sequence><xsd:any minOccurs="0" maxOccurs="1"/></xsd:sequence><xsd:attribute type="xsd:anySimpleType" name="each" default="NULL" use="required"><xsd:annotation><xsd:documentation><![CDATA[The array or \SplObjectStorage to iterated over]]></xsd:documentation></xsd:annotation></xsd:attribute><xsd:attribute type="xsd:string" name="as" default="NULL" use="required"><xsd:annotation><xsd:documentation><![CDATA[The name of the iteration variable]]></xsd:documentation></xsd:annotation></xsd:attribute><xsd:attribute type="xsd:string" name="groupBy" default="NULL" use="required"><xsd:annotation><xsd:documentation><![CDATA[Group by this property]]></xsd:documentation></xsd:annotation></xsd:attribute><xsd:attribute type="xsd:string" name="groupKey" default="'groupKey'"><xsd:annotation><xsd:documentation><![CDATA[The name of the variable to store the current group]]></xsd:documentation></xsd:annotation></xsd:attribute></xsd:complexType></xsd:element><xsd:element name="if"><xsd:annotation><xsd:documentation><![CDATA[This ViewHelper implements an if/else condition.

Fluid Boolean Rules / Conditions:
=================================

A condition is evaluated as a boolean value, so you can use any
boolean argument, like a variable.
Alternatively, you can use a full boolean expression.
The entered expression is evaluated as a PHP expression. You can
combine multiple expressions via :php:`&&` (logical AND) and
:php:`||` (logical OR).

An expression can also be prepended with the :php:`!` ("not") character,
which will negate that expression.

Have a look into the Fluid section of the "TYPO3 Explained" Documentation
for more details about complex conditions.

Boolean expressions have the following form:

`is true` variant: `{variable}`::

      <f:if condition="{foo}">
          Will be shown if foo is truthy.
      </f:if>

or `is false` variant: `!{variable}`::

      <f:if condition="!{foo}">
          Will be shown if foo is falsy.
      </f:if>

or comparisons with expressions::

      XX Comparator YY

Comparator is one of: :php:`==, !=, <, <=, >, >=` and :php:`%`
The :php:`%` operator (modulo) converts the result of the operation to
boolean.

`XX` and `YY` can be one of:

- Number
- String
- Object Accessor (`object.property`)
- Array
- a ViewHelper

::

      <f:if condition="{rank} > 100">
          Will be shown if rank is > 100
      </f:if>
      <f:if condition="{rank} % 2">
          Will be shown if rank % 2 != 0.
      </f:if>
      <f:if condition="{rank} == {k:bar()}">
          Checks if rank is equal to the result of the ViewHelper "k:bar"
      </f:if>
      <f:if condition="{object.property} == 'stringToCompare'">
          Will result in true if {object.property}'s represented value
          equals 'stringToCompare'.
      </f:if>

Examples
========

Basic usage
-----------

::

    <f:if condition="somecondition">
        This is being shown in case the condition matches
    </f:if>

Output::

    Everything inside the <f:if> tag is being displayed if the condition evaluates to TRUE.

If / then / else
----------------

::

    <f:if condition="somecondition">
        <f:then>
            This is being shown in case the condition matches.
        </f:then>
        <f:else>
            This is being displayed in case the condition evaluates to FALSE.
        </f:else>
    </f:if>

Output::

    Everything inside the "then" tag is displayed if the condition evaluates to TRUE.
    Otherwise, everything inside the "else" tag is displayed.

Inline notation
---------------

::

    {f:if(condition: someCondition, then: 'condition is met', else: 'condition is not met')}

Output::

    The value of the "then" attribute is displayed if the condition evaluates to TRUE.
    Otherwise, everything the value of the "else" attribute is displayed.

Combining multiple conditions
-----------------------------

::

    <f:if condition="{user.rank} > 100 && {user.type} == 'contributor'">
        <f:then>
            This is being shown in case both conditions match.
        </f:then>
        <f:else if="{user.rank} > 200 && ({user.type} == 'contributor' || {user.type} == 'developer')">
            This is being displayed in case the first block of the condition evaluates to TRUE and any condition in
            the second condition block evaluates to TRUE.
        </f:else>
        <f:else>
            This is being displayed when none of the above conditions evaluated to TRUE.
        </f:else>
    </f:if>

Output::

    Depending on which expression evaluated to TRUE, that value is displayed.
    If no expression matched, the contents inside the final "else" tag are displayed.

/]]></xsd:documentation></xsd:annotation><xsd:complexType mixed="true"><xsd:sequence><xsd:any minOccurs="0" maxOccurs="1"/></xsd:sequence><xsd:attribute type="xsd:anySimpleType" name="then" default="NULL"><xsd:annotation><xsd:documentation><![CDATA[Value to be returned if the condition if met.]]></xsd:documentation></xsd:annotation></xsd:attribute><xsd:attribute type="xsd:anySimpleType" name="else" default="NULL"><xsd:annotation><xsd:documentation><![CDATA[Value to be returned if the condition if not met.]]></xsd:documentation></xsd:annotation></xsd:attribute><xsd:attribute type="xsd:boolean" name="condition" default="false"><xsd:annotation><xsd:documentation><![CDATA[Condition expression conforming to Fluid boolean rules]]></xsd:documentation></xsd:annotation></xsd:attribute></xsd:complexType></xsd:element><xsd:element name="inline"><xsd:annotation><xsd:documentation><![CDATA[Inline Fluid rendering ViewHelper

Renders Fluid code stored in a variable, which you normally would
have to render before assigning it to the view. Instead you can
do the following (note, extremely simplified use case)::

     $view->assign('variable', 'value of my variable');
     $view->assign('code', 'My variable: {variable}');

And in the template::

     {code -> f:inline()}

Which outputs::

     My variable: value of my variable

You can use this to pass smaller and dynamic pieces of Fluid code
to templates, as an alternative to creating new partial templates.
/]]></xsd:documentation></xsd:annotation><xsd:complexType mixed="true"><xsd:sequence><xsd:any minOccurs="0" maxOccurs="1"/></xsd:sequence><xsd:attribute type="xsd:string" name="code" default="NULL"><xsd:annotation><xsd:documentation><![CDATA[Fluid code to be rendered as if it were part of the template rendering it. Can be passed as inline argument or tag content]]></xsd:documentation></xsd:annotation></xsd:attribute></xsd:complexType></xsd:element><xsd:element name="join"><xsd:annotation><xsd:documentation><![CDATA[The JoinViewHelper combines elements from an array into a single string.
You can specify both a general separator and a special one for the last
element, which serves as the delimiter between the elements.


Examples
========

Simple join
-----------
::

   <f:join value="{0: '1', 1: '2', 2: '3'}" />

.. code-block:: text

   123


Join with separator
-------------------

::

   <f:join value="{0: '1', 1: '2', 2: '3'}" separator=", " />

.. code-block:: text

   1, 2, 3


Join with separator, and special one for the last
-------------------------------------------------

::

   <f:join value="{0: '1', 1: '2', 2: '3'}" separator=", " separatorLast=" and " />

.. code-block:: text

   1, 2 and 3
/]]></xsd:documentation></xsd:annotation><xsd:complexType mixed="true"><xsd:sequence><xsd:any minOccurs="0" maxOccurs="1"/></xsd:sequence><xsd:attribute type="xsd:anySimpleType" name="value" default="NULL"><xsd:annotation><xsd:documentation><![CDATA[An array]]></xsd:documentation></xsd:annotation></xsd:attribute><xsd:attribute type="xsd:string" name="separator" default="''"><xsd:annotation><xsd:documentation><![CDATA[The separator]]></xsd:documentation></xsd:annotation></xsd:attribute><xsd:attribute type="xsd:string" name="separatorLast" default="NULL"><xsd:annotation><xsd:documentation><![CDATA[The separator for the last pair.]]></xsd:documentation></xsd:annotation></xsd:attribute></xsd:complexType></xsd:element><xsd:element name="last"><xsd:annotation><xsd:documentation><![CDATA[The LastViewHelper returns the last item of an array.

Example
========

::

   <f:last value="{0: 'first', 1: 'second'}" />

.. code-block:: text

   second
/]]></xsd:documentation></xsd:annotation><xsd:complexType mixed="true"><xsd:sequence><xsd:any minOccurs="0" maxOccurs="1"/></xsd:sequence><xsd:attribute type="xsd:anySimpleType" name="value" default="NULL"><xsd:annotation><xsd:documentation><![CDATA[]]></xsd:documentation></xsd:annotation></xsd:attribute></xsd:complexType></xsd:element><xsd:element name="layout"><xsd:annotation><xsd:documentation><![CDATA[With this tag, you can select a layout to be used for the current template.

Examples
========

::

    <f:layout name="main" />

Output::

    (no output)

/]]></xsd:documentation></xsd:annotation><xsd:complexType mixed="true"><xsd:sequence><xsd:any minOccurs="0" maxOccurs="1"/></xsd:sequence><xsd:attribute type="xsd:string" name="name" default="NULL"><xsd:annotation><xsd:documentation><![CDATA[Name of layout to use. If none given, "Default" is used.]]></xsd:documentation></xsd:annotation></xsd:attribute></xsd:complexType></xsd:element><xsd:element name="or"><xsd:annotation><xsd:documentation><![CDATA[Or ViewHelper

If content is null use alternative text.

Usage of f:or
=============

::

    {f:variable(name:'fallback',value:'this is not the variable you\'re looking for')}
    {undefinedVariable -> f:or(alternative:fallback)}

Usage of ternary operator
=========================

In some cases (e.g. when you want to check for empty instead of null)
it might be more handy to use a ternary operator instead of f:or

::

    {emptyVariable ?: 'this is an alterative text'}
/]]></xsd:documentation></xsd:annotation><xsd:complexType mixed="true"><xsd:sequence><xsd:any minOccurs="0" maxOccurs="1"/></xsd:sequence><xsd:attribute type="xsd:anySimpleType" name="content" default="NULL"><xsd:annotation><xsd:documentation><![CDATA[Content to check if null]]></xsd:documentation></xsd:annotation></xsd:attribute><xsd:attribute type="xsd:anySimpleType" name="alternative" default="NULL"><xsd:annotation><xsd:documentation><![CDATA[Alternative if content is null]]></xsd:documentation></xsd:annotation></xsd:attribute><xsd:attribute type="xsd:anySimpleType" name="arguments" default="NULL"><xsd:annotation><xsd:documentation><![CDATA[Arguments to be replaced in the resulting string, using sprintf]]></xsd:documentation></xsd:annotation></xsd:attribute></xsd:complexType></xsd:element><xsd:element name="render"><xsd:annotation><xsd:documentation><![CDATA[A ViewHelper to render a section, a partial, a specified section in a partial
or a delegate ParsedTemplateInterface implementation.

Examples
========

Rendering partials
------------------

::

    <f:render partial="SomePartial" arguments="{foo: someVariable}" />

Output::

    the content of the partial "SomePartial". The content of the variable {someVariable} will be available in the partial as {foo}

Rendering sections
------------------

::

    <f:section name="someSection">This is a section. {foo}</f:section>
    <f:render section="someSection" arguments="{foo: someVariable}" />

Output::

    the content of the section "someSection". The content of the variable {someVariable} will be available in the partial as {foo}

Rendering recursive sections
----------------------------

::

    <f:section name="mySection">
        <ul>
            <f:for each="{myMenu}" as="menuItem">
                <li>
                    {menuItem.text}
                    <f:if condition="{menuItem.subItems}">
                        <f:render section="mySection" arguments="{myMenu: menuItem.subItems}" />
                    </f:if>
                </li>
            </f:for>
        </ul>
       </f:section>
       <f:render section="mySection" arguments="{myMenu: menu}" />

Output::

    <ul>
        <li>menu1
            <ul>
              <li>menu1a</li>
              <li>menu1b</li>
            </ul>
        </li>
    [...]
    (depending on the value of {menu})


Passing all variables to a partial
----------------------------------

::

    <f:render partial="somePartial" arguments="{_all}" />

Output::

    the content of the partial "somePartial".
    Using the reserved keyword "_all", all available variables will be passed along to the partial


Rendering via a delegate ParsedTemplateInterface implementation w/ custom arguments
-----------------------------------------------------------------------------------

::

    <f:render delegate="My\Special\ParsedTemplateImplementation" arguments="{_all}" />

This will output whichever output was generated by calling ``My\Special\ParsedTemplateImplementation->render()``
with cloned RenderingContextInterface $renderingContext as only argument and content of arguments
assigned in VariableProvider of cloned context. Supports all other input arguments including
recursive rendering, contentAs argument, default value etc.

Note that while ParsedTemplateInterface supports returning a Layout name, this Layout will not
be respected when rendering using this method. Only the ``render()`` method will be called!

/]]></xsd:documentation></xsd:annotation><xsd:complexType mixed="true"><xsd:sequence><xsd:any minOccurs="0" maxOccurs="1"/></xsd:sequence><xsd:attribute type="xsd:string" name="section" default="NULL"><xsd:annotation><xsd:documentation><![CDATA[Section to render - combine with partial to render section in partial]]></xsd:documentation></xsd:annotation></xsd:attribute><xsd:attribute type="xsd:string" name="partial" default="NULL"><xsd:annotation><xsd:documentation><![CDATA[Partial to render, with or without section]]></xsd:documentation></xsd:annotation></xsd:attribute><xsd:attribute type="xsd:string" name="delegate" default="NULL"><xsd:annotation><xsd:documentation><![CDATA[Optional PHP class name of a permanent, included-in-app ParsedTemplateInterface implementation to override partial/section]]></xsd:documentation></xsd:annotation></xsd:attribute><xsd:attribute type="xsd:anySimpleType" name="arguments" default="array (&#10;)"><xsd:annotation><xsd:documentation><![CDATA[Array of variables to be transferred. Use {_all} for all variables]]></xsd:documentation></xsd:annotation></xsd:attribute><xsd:attribute type="xsd:boolean" name="optional" default="false"><xsd:annotation><xsd:documentation><![CDATA[If TRUE, considers the *section* optional. Partial never is.]]></xsd:documentation></xsd:annotation></xsd:attribute><xsd:attribute type="xsd:anySimpleType" name="default" default="NULL"><xsd:annotation><xsd:documentation><![CDATA[Value (usually string) to be displayed if the section or partial does not exist]]></xsd:documentation></xsd:annotation></xsd:attribute><xsd:attribute type="xsd:string" name="contentAs" default="NULL"><xsd:annotation><xsd:documentation><![CDATA[If used, renders the child content and adds it as a template variable with this name for use in the partial/section]]></xsd:documentation></xsd:annotation></xsd:attribute></xsd:complexType></xsd:element><xsd:element name="replace"><xsd:annotation><xsd:documentation><![CDATA[The ReplaceViewHelper replaces one or multiple strings with other
strings. This ViewHelper mimicks PHP's :php:`str_replace()` function.
However, it's also possible to provide replace pairs as associative array
via the "replace" argument.


Examples
========

Replace a single string
-----------------------
::

   <f:replace value="Hello World" search="World" replace="Fluid" />

.. code-block:: text

   Hello Fluid


Replace multiple strings
------------------------
::

   <f:replace value="Hello World" search="{0: 'World', 1: 'Hello'}" replace="{0: 'Fluid', 1: 'Hi'}" />

.. code-block:: text

   Hi Fluid


Replace multiple strings using associative array
------------------------------------------------
::

   <f:replace value="Hello World" replace="{'World': 'Fluid', 'Hello': 'Hi'}" />

.. code-block:: text

   Hi Fluid
/]]></xsd:documentation></xsd:annotation><xsd:complexType mixed="true"><xsd:sequence><xsd:any minOccurs="0" maxOccurs="1"/></xsd:sequence><xsd:attribute type="xsd:string" name="value" default="NULL"><xsd:annotation><xsd:documentation><![CDATA[]]></xsd:documentation></xsd:annotation></xsd:attribute><xsd:attribute type="xsd:anySimpleType" name="search" default="NULL"><xsd:annotation><xsd:documentation><![CDATA[]]></xsd:documentation></xsd:annotation></xsd:attribute><xsd:attribute type="xsd:anySimpleType" name="replace" default="NULL" use="required"><xsd:annotation><xsd:documentation><![CDATA[]]></xsd:documentation></xsd:annotation></xsd:attribute></xsd:complexType></xsd:element><xsd:element name="section"><xsd:annotation><xsd:documentation><![CDATA[A ViewHelper to declare sections in templates for later use with e.g. the ``f:render`` ViewHelper.

Examples
========

Rendering sections
------------------

::

    <f:section name="someSection">This is a section. {foo}</f:section>
    <f:render section="someSection" arguments="{foo: someVariable}" />

Output::

    the content of the section "someSection". The content of the variable {someVariable} will be available in the partial as {foo}

Rendering recursive sections
----------------------------

::

    <f:section name="mySection">
       <ul>
            <f:for each="{myMenu}" as="menuItem">
                 <li>
                   {menuItem.text}
                   <f:if condition="{menuItem.subItems}">
                       <f:render section="mySection" arguments="{myMenu: menuItem.subItems}" />
                   </f:if>
                 </li>
            </f:for>
       </ul>
    </f:section>
    <f:render section="mySection" arguments="{myMenu: menu}" />

Output::

    <ul>
        <li>menu1
            <ul>
                <li>menu1a</li>
                <li>menu1b</li>
            </ul>
        </li>
    [...]
    (depending on the value of {menu})

/]]></xsd:documentation></xsd:annotation><xsd:complexType mixed="true"><xsd:sequence><xsd:any minOccurs="0" maxOccurs="1"/></xsd:sequence><xsd:attribute type="xsd:string" name="name" default="NULL" use="required"><xsd:annotation><xsd:documentation><![CDATA[Name of the section]]></xsd:documentation></xsd:annotation></xsd:attribute></xsd:complexType></xsd:element><xsd:element name="spaceless"><xsd:annotation><xsd:documentation><![CDATA[Space Removal ViewHelper

Removes redundant spaces between HTML tags while
preserving the whitespace that may be inside HTML
tags. Trims the final result before output.

Heavily inspired by Twig's corresponding node type.

Usage of f:spaceless
====================

::

    <f:spaceless>
        <div>
            <div>
                <div>text

        text</div>
            </div>
        </div>
    </f:spaceless>

Output::

    <div><div><div>text

    text</div></div></div>
/]]></xsd:documentation></xsd:annotation><xsd:complexType mixed="true"><xsd:sequence><xsd:any minOccurs="0" maxOccurs="1"/></xsd:sequence></xsd:complexType></xsd:element><xsd:element name="split"><xsd:annotation><xsd:documentation><![CDATA[The SplitViewHelper splits a string by the specified separator, which
results in an array. The number of values in the resulting array can
be limited with the limit parameter, which results in an array where
the last item contains the remaining unsplit string.

This ViewHelper mimicks PHP's :php:`explode()` function.


Examples
========

Split with a separator
-----------------------
::

   <f:split value="1,5,8" separator="," />

.. code-block:: text

   {0: '1', 1: '5', 2: '8'}


Split using tag content as value
--------------------------------

::

   <f:split separator="-">1-5-8</f:split>

.. code-block:: text

   {0: '1', 1: '5', 2: '8'}


Split with a limit
-------------------

::

   <f:split value="1,5,8" separator="," limit="2" />

.. code-block:: text

   {0: '1', 1: '5,8'}
/]]></xsd:documentation></xsd:annotation><xsd:complexType mixed="true"><xsd:sequence><xsd:any minOccurs="0" maxOccurs="1"/></xsd:sequence><xsd:attribute type="xsd:string" name="value" default="NULL"><xsd:annotation><xsd:documentation><![CDATA[The string to explode]]></xsd:documentation></xsd:annotation></xsd:attribute><xsd:attribute type="xsd:string" name="separator" default="NULL" use="required"><xsd:annotation><xsd:documentation><![CDATA[Separator string to explode with]]></xsd:documentation></xsd:annotation></xsd:attribute><xsd:attribute type="xsd:anySimpleType" name="limit" default="9223372036854775807"><xsd:annotation><xsd:documentation><![CDATA[If limit is positive, a maximum of $limit items will be returned. If limit is negative, all items except for the last $limit items will be returned. 0 will be treated as 1.]]></xsd:documentation></xsd:annotation></xsd:attribute></xsd:complexType></xsd:element><xsd:element name="switch"><xsd:annotation><xsd:documentation><![CDATA[Switch ViewHelper which can be used to render content depending on a value or expression.
Implements what a basic PHP ``switch()`` does.

An optional default case can be specified which is rendered if none of the
``case`` conditions matches.

Using this ViewHelper can be a sign of weak architecture. If you end up using it extensively
you might want to consider restructuring your controllers/actions and/or use partials and sections.
E.g. the above example could be achieved with :html:`<f:render partial="title.{person.gender}" />`
and the partials "title.male.html", "title.female.html", ...
Depending on the scenario this can be easier to extend and possibly contains less duplication.

Examples
========

Simple Switch statement
-----------------------

::

    <f:switch expression="{person.gender}">
        <f:case value="male">Mr.</f:case>
        <f:case value="female">Mrs.</f:case>
        <f:defaultCase>Mr. / Mrs.</f:defaultCase>
    </f:switch>

Output::

    "Mr.", "Mrs." or "Mr. / Mrs." (depending on the value of {person.gender})

/]]></xsd:documentation></xsd:annotation><xsd:complexType mixed="true"><xsd:sequence><xsd:any minOccurs="0" maxOccurs="1"/></xsd:sequence><xsd:attribute type="xsd:anySimpleType" name="expression" default="NULL" use="required"><xsd:annotation><xsd:documentation><![CDATA[Expression to switch]]></xsd:documentation></xsd:annotation></xsd:attribute></xsd:complexType></xsd:element><xsd:element name="then"><xsd:annotation><xsd:documentation><![CDATA[``f:then`` only has an effect inside of ``f:if``. See the ``f:if`` ViewHelper for documentation.

/]]></xsd:documentation></xsd:annotation><xsd:complexType mixed="true"><xsd:sequence><xsd:any minOccurs="0" maxOccurs="1"/></xsd:sequence></xsd:complexType></xsd:element><xsd:element name="variable"><xsd:annotation><xsd:documentation><![CDATA[Variable assigning ViewHelper

Assigns one template variable which will exist also
after the ViewHelper is done rendering, i.e. adds
template variables.

If you require a variable assignment which does not
exist in the template after a piece of Fluid code
is rendered, consider using ``f:alias`` ViewHelper instead.

Usages:

::

    {f:variable(name: 'myvariable', value: 'some value')}
    <f:variable name="myvariable">some value</f:variable>
    {oldvariable -> f:format.htmlspecialchars() -> f:variable(name: 'newvariable')}
    <f:variable name="myvariable"><f:format.htmlspecialchars>{oldvariable}</f:format.htmlspecialchars></f:variable>

/]]></xsd:documentation></xsd:annotation><xsd:complexType mixed="true"><xsd:sequence><xsd:any minOccurs="0" maxOccurs="1"/></xsd:sequence><xsd:attribute type="xsd:anySimpleType" name="value" default="NULL"><xsd:annotation><xsd:documentation><![CDATA[Value to assign. If not in arguments then taken from tag content]]></xsd:documentation></xsd:annotation></xsd:attribute><xsd:attribute type="xsd:string" name="name" default="NULL" use="required"><xsd:annotation><xsd:documentation><![CDATA[Name of variable to create]]></xsd:documentation></xsd:annotation></xsd:attribute></xsd:complexType></xsd:element></xsd:schema>
